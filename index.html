<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Async Javascript</title>

		<script src="https://use.typekit.net/dkq5epu.js"></script>
		<script>try{Typekit.load({ async: true });}catch(e){}</script>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/kaliber5.css">
		<link rel="stylesheet" href="css/spinner.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Async Javascript</h1>
					<h2>Callbacks, Promises, Async/Await</h2>
					<div class="floatingBarsG">
						<div class="blockG rotateG_01"></div>
						<div class="blockG rotateG_02"></div>
						<div class="blockG rotateG_03"></div>
						<div class="blockG rotateG_04"></div>
						<div class="blockG rotateG_05"></div>
						<div class="blockG rotateG_06"></div>
						<div class="blockG rotateG_07"></div>
						<div class="blockG rotateG_08"></div>
					</div>
				</section>
				<section>
					<div class="id-card">
						<dl>
							<dt>Name</dt>
							<dd>Andreas Schacht</dd>
							<dt>Company</dt>
							<dd><a href="http://www.kaliber5.de">kaliber5</a></dd>
							<dt>Job title</dt>
							<dd>Web Developer</dd>
							<dt>Email</dt>
							<dd><a href="mailto:schacht@kaliber5.de">schacht@kaliber5.de</a></dd>
						</dl>
					</div>
					<aside class="notes">
						- Async exec code doesn't mean in the background
					</aside>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Excursion: Event Loop
						- Async executed code also blocks UI

						- Talk from Philip Roberts @JSConf EU 2014:

						[What the heck is the event loop anyway?](https://www.youtube.com/watch?v=8aGhZQkoFbQ)



						Note:
						- very common use case
						- process depends on result of previous one
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Excursion: Event Loop
						![alt stack](/img/stack.png "stack and event queue")



						Note:
						- very common use case
						- process depends on result of previous one
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## TOC
						what will I talk about
						- sync example
						- callback example
						- promise example
						- async/await example
						- async with generators
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Sync

						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						let result = doSomething();
						console.log(result);
						```
						Note:
						- very common use case
						- process depends on result of previous one
						- concurrently running tasks
						- race conditions, semaphores, locks
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Sync

						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						try {
							let result = doSomething();
							console.log(result);
						} catch(err) {
							console.error(err);
						}
						```
						- handle errors
					</script>
				</section>
				<section>
					<div class="floatingBarsG">
						<div class="blockG rotateG_01"></div>
						<div class="blockG rotateG_02"></div>
						<div class="blockG rotateG_03"></div>
						<div class="blockG rotateG_04"></div>
						<div class="blockG rotateG_05"></div>
						<div class="blockG rotateG_06"></div>
						<div class="blockG rotateG_07"></div>
						<div class="blockG rotateG_08"></div>
					</div>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Callbacks
						```js
						function bar(value) {
							console.log(value);
						}

						function foo(cb) {
							setTimeout(function() {
								// do some work
								cb(2);
							}, 0);
						}

						foo(bar);
						console.log(1);

						//-> 1
						//-> 2
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Callbacks

						```js
						const fs = require('fs');

						fs.readFile('./README.md', (err, data) => {
							// do some work here
						});
						```
						- "error-first"- / "errback"-convention
						- err is null on success

						Note:
						- respect error handling
						- avoid forget/skip err
						- signature is just a convention
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Callbacks

						```js
						const fs = require('fs');

						fs.readFile('./README.md', (err, data) => {
							if (err) {
								// handle error
							} else {
								// process data
							}
						});

						```
						Note:
						- construct will look like this
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Callbacks

						```js
						const fs = require('fs');

						try {
							fs.readFile('./README.md', (err, data) => {
								if (err) {
									throw err;
								}
								console.log('done');
							});
						} catch(err) {
							console.error(err);
						}
						```
						- try / catch won't work
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Callbacks

						```js
						function doSomething(cb) {
							foo((err, data) => {
								bar(data, (err, data) => {
									baz(data, cb);
								});
							});
						}

						doSomething((err, data) => {
							console.log(data);
						});
						```
						Note:
						- harder to read
						- indentation
						- nested level 3
						- not finished yet
							- handle errors
					</script>
				</section>
				<section data-markdown class="md-small md-code-large">
					<script type="text/template">
						#### Callbacks

						```js
						function doSomething(cb) {
							foo((err, data) => {
								if (err) {
									cb(err);
								} else {
									bar(data, (err, data) => {
										if (err) {
											cb(err);
										} else {
											baz(data, cb);
										}
									});
								}
							});
						}

						doSomething((err, data) => {
							if (err) {
								console.error(err);
							} else {
								console.log(data);
							}
						});
						```
						- error handling
						Note:
						- very hard to read
						- indentation, high nested level
						- callback hell
						- shape of pyramid
						- known as pyramid of doom
						- exit as soon as possible
						- skip else block
						- skip further execution
					</script>
				</section>
				<section data-markdown class="md-small md-code-large">
					<script type="text/template">
						#### Callbacks

						```js
						function doSomething(cb) {
							foo((err, data) => {
								if (err) {
									return cb(err);
								}
								bar(data, (err, data) => {
									if (err) {
										return cb(err);
									}
									baz(data, cb);
								});
							});
						}

						doSomething((err, data) => {
							if (err) {
								return console.error(err);
							}
							console.log(data);
						});
						```
						- exit as soon as possible
						Note:
						- skip else block
						- skip further execution
						- compare to sync example
					</script>
				</section>
				<section data-markdown class="md-small md-code-large">
					<script type="text/template">
						#### Callbacks vs Sync
						```js
						function doSomething(cb) {
							foo((err, data) => {
								if (err) {
									return cb(err);
								}
								bar(data, (err, data) => {
									if (err) {
										return cb(err);
									}
									baz(data, cb);
								});
							});
						}

						doSomething((err, data) => {
							if (err) {
								return console.error(err);
							}
							console.log(data);
						});
						```
						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						try {
							let result = doSomething();
							console.log(result);
						} catch(err) {
							console.error(err);
						}
						```
						Note:
						- high indentation level
						- lost readability
							- not really intuitive like first
						- many blocks
						- far away from first example
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						- objects represents an eventual result/failure

						```js
						new Promise(function(resolve, reject) { ... } );
						```
						<div class="fragment fade-in">
						- states
						<pre>pending := !fulfilled && !rejected</pre>
						<pre>fulfilled</pre>
						<pre>rejected</pre>
						</div>
						Note:
						- became 1st class citizen of modern frameworks
						- avoid basics
						- focus on traps/edge cases
						- pass executor function
						- pending is initial state
						- settled := !pending <=> fulfilled || rejected
						- resolved := fulfilled || rejected || follow thenable/promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
							new Promise((resolve, reject) => {
								// executes immediatly
								// do some work
								// pending state
								if (foo) {
									resolve(foo);
									// fulfilled state
								} else {
									reject(reason);
									// rejected state
								}
							});
						```
						Note:
							- work should be async
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						Promise.reject('reason');
						// state rejected

						Promise.resolve('value');
						// state fulfilled

						Promise.resolve(Promise.reject('reason'));
						// return passed Promise, state rejected
						```
						Note:
						- if pass a promise, resolve returns that promise
					</script>
					</section>
					<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						Promise.all([
							Promise.resolve('val1'),
							Promise.resolve('val2')
						]); // resolves async, state pending, will fulfill

						Promise.all([]); // resolves sync, state fulfilled

						Promise.all([
							'val1',
							'val2'
						]); // resolves async (sync on Chrome 58), state pending (fulfilled), will fulfill

						Promise.all([
							Promise.resolve('value'),
							Promise.reject('reason')
						]); // resolves sync, state rejected
						```
						Note:
						- Promise.all(iterable); Array/String
						- all is fulfilled, if all promises are fulfilled
						- all is rejected, if at least one promise is rejected
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						Promise.race([
							Promise.resolve('val1'),
							Promise.reject('val2')
						]); // state pending, will fulfill with value: 'val1'

						Promise.race([
							Promise.reject('val2'),
							Promise.resolve('val1')
						]); // state pending, will reject with reason: 'val2'

						Promise.race([]); // will pending forever
						```
						Note:
						- Promise.race(iterable); Array/String
						- race follows the first settled
						- race pending foreverfollows the first settled
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises

						```js
						Promise.prototype.then(onFulfilled[, onRejected]);

						Promise.resolve('value').then((data) => {
							console.log(data);
						});

						Promise.reject('reason').then((data) => {},
						(reason) => {
								console.error(reason);
						});

						Promise.prototype.catch(onRejected);

						Promise.reject('reason').catch((reason) => {
							console.error(reason);
						});
						```
						Note:
						- provides then/catch
						- catch is the same as then(null, onRejected)
						- returns a promise, so it's chainable
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.reject(Error('test'));

						 // -> Uncaught (in promise) Error: test
						```
						Note:
						- keep in mind, then/catch returns a promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.reject(Error('test'));
						promise.catch((error) => {
							// handle error
						});

						 // -> No output
						```
						Note:
						- keep in mind, then/catch returns a promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.reject(Error('test'));
						promise.catch((error) => {
							// handle error
						});

						promise.then((value) => {
							// will never executed
						});
						 // -> Uncaught (in promise) Error: test
						```
						Note:
						- keep in mind, then/catch returns a promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.reject(Error('test'));
						promise.catch((error) => {
							// handle error
						});

						promise.then((value) => {
							// will never executed
						}, (err) => {});

						promise.then((value) => {
							// will never executed
						}).catch((err) => {});
						// -> No output
						```
						Note:
						- keep in mind, then/catch returns a promise
						- chain multiple methods on same promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.resolve({ name: 'Andreas'});
						promise.then((value) => {
							console.log('1: '+value.name);
							value.name = 'Andi';
							return value;
						}).then((value) => {
							console.log('2: '+value.name);
						});
						// -> 1: Andreas
						// -> 2: Andy
						```
						Note:
						- chain multiple methods on same promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.resolve({ name: 'Andreas'});
						promise.then((value) => {
							console.log('1: '+value.name);
							value.name = 'Andi';
							return value;
						}).then((value) => {
							console.log('2: '+value.name);
						});
						// ....
						promise.then((value) => {
							console.log('1.5: '+value.name);
							value.name = 'Andy';
						});
						// -> 1: Andreas
						// -> 1.5: Andi
						// -> 2: Andy
						```
						Note:
						- idea
						- chain multiple methods on same promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						#### chainable

						```js
						Promise.resolve().then((data) => {
							return Promise.resolve('data');
						}).then((data) => {
							console.log(data); // -> 'data'
							return 42;
						}).then(undefined, (error) => {
							// this will never been reached
						}).then((data) => {
							console.log(data); // -> 42
							throw Error('message');
						}).then((data) => {
							// this will never been reached
						}).catch((error) => {
							// handle error;
						});

						```
						Note:
						- chainable through then function
						- value will pass through the chain to the next handler, if undefined (or not a function)
					</script>
				</section>
<!--
				<section data-markdown>
					<script type="text/template">
						## Promises
						#### wrap callback style

						```js
						const fs = require('fs');

						fs.readFile('./README.md', (err, data) => {
							if (err) {
								// handle error
							} else {
								// process data
							}
						});

						```
						Note:
						- tired of callbacks
						- from previous explaination
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						#### wrap callback style

						```js
						const fs = require('fs');

						let promise = new Promise((resolve, reject) => {
							fs.readFile('./README.md', (err, data) => {
								if (err) {
									return reject(err);
								}
								resolve(data);
							});
						});

						promise.then((data) => {
							// will be called, if promise resolves
						}).catch((err) => {
							// will be called, when promise rejects
						});

						```
					</script>
				</section>
	-->
				<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						function doSomething() {
							return Promise.resolve(foo())
								.then((data) => {
									return bar(data);
								})
								.then((data) => {
									return baz(data);
								});
						}

						doSomething().then((data) => {
							console.log(data);
						}).catch((error) => {
							console.error(error);
						});
						```
						Note:
						- short syntax
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						function doSomething() {
							return Promise.resolve()
								.then(foo)
								.then(bar)
								.then(baz);
						}

						doSomething().then((data) => {
							console.log(data);
						}).catch((error) => {
							console.error(error);
						});
						```
						Note:
						- short syntax
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### Promises vs Sync
						```js
						function doSomething() {
							return Promise.resolve()
								.then(foo)
								.then(bar)
								.then(baz);
						}

						doSomething().then((data) => {
							console.log(data);
						}).catch((error) =>
							console.error(error);
						});
						```
						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						try {
							let result = doSomething();
							console.log(result);
						} catch(err) {
							console.error(err);
						}
						```
						Note:
						- good, but not satisfied
						- have another bullet
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### async / await
						- RC ES7
						- `async function`-declaration
							- defines an asynchronous function
							- async function call returns a promise
						- `await` operator
							- can only be used in async functions
							- suspending execution
							- until following expression is resolved
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### async / await
						```js
						async function foo() {
							return 'value';
							return Promise.resolve('value');

							return Promise.reject(Error('reason'));
							throw Error('reason');
							await Promise.reject(Error('reason'));
						}
						let fooPromise = foo();
						```
						Note:
						- what happens
							- onFulfill: await returns the resolved value
							- onRejection: await throws an error
								- promise returned by async rejects
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### async / await
						```js
						async function foo() {
							try {
								let value = await Promise.resolve('value');
								await Promise.reject(Error('reason'));
								// never reached
								return value;
							} catch(error) {
								// handle error
								// return fallbackValue;
								// 	or
								// throw error;
							}
						...
						}
						```
						Note:
						- try / catch like in sync context
						- Now see our Example
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### async/await vs Sync
						```js
						async function doSomething() {
							let data = await foo();
							data = await bar(data);
							return await baz(data);
						}

						doSomething().then((data) => {
							console.log(data);
						}).catch((error) =>
							console.error(error);
						});
						```
						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						try {
							let result = doSomething();
							console.log(result);
						} catch(err) {
							console.error(err);
						}
						```
						Note:
						- almost the same
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### async / await
						parallel execution
						```js

						async function () {
							let promA = new Promise(...);
							let promB = new Promise(...);

							return await promA + await promB;
						}

						async function () {
							let [resultA, resultB] = await Promise.all([
								new Promise(...),
								new Promise(...)
							]);

							return resultA + resultBB;
						}
						```
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator function
						- declaration: function keyword followed by an asterisk

						```js
						function* genFunc([param[, ... param]]) { statements }

						let genObj = genFunc();
						```
						Note:
						- The function* declaration
						- (function keyword followed by an asterisk)
						- defines a generator function
						- generator function
						- generator object
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator object
						```js
						Generator.prototype.next()

						Generator.prototype.return()

						Generator.prototype.throw()
						```
						Note:
						- Returns a value yielded by the yield expression.
						- Returns the given value and finishes the generator.
						- Throws an error to a generator.
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generators
						- next()

						```js
						function* fibonacci() {
							let current = 0;
							let next = 1;
							while (true) {
								yield current;
								[current, next] = [next, current + next];
							}
						}

						let sequence = fibonacci();
						console.log(sequence.next());     // { done: false, value: 0}
						console.log(sequence.next().value);     // 1
						console.log(sequence.next().value);     // 1
						console.log(sequence.next().value); 		// 2
						```
						Note:
						- generator function
						- generator object
						- pass arg to next
						- yield suspend / next resumes
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generators
						- next()

						```js
						function* fibonacci() {
							let reset = true, current, next;
							while (true) {
								if (reset){
									current = 0;
									next = 1;
								}
								reset = yield current;
								[current, next] = [next, current + next];
							}
						}

						let sequence = fibonacci();
						console.log(sequence.next());     // { done: false, value: 0}
						console.log(sequence.next().value);     // 1
						console.log(sequence.next().value);     // 1
						console.log(sequence.next(true).value); // 0
						```
						Note:
						- generator function
						- generator object
						- pass arg to next
						- suspend / resume
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator
						- return()

						```js
						function* gen() {
							yield 1;
							yield 2;
							yield 3;
						}

						var g = gen();
						g.next();        // { value: 1, done: false }
						g.return();      // { value: undefined, done: true }
						g.return('foo'); // { value: "foo", done: true }
						g.next();        // { value: undefined, done: true }
						```
						Note:
						- return returns the passed value and finished genObj
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator
						- throw()

						```js
						function* gen() {
							while(true) {
								try {
									 yield 42;
								} catch(e) {
									console.log('Error caught!');
								}
							}
						}

						var g = gen();
						g.next();
						// { value: 42, done: false }
						g.throw(new Error('Something went wrong'));
						// "Error caught!"
						// { value: 42, done: false }
						```
						Note:
						- throw() method resumes the execution by throwing an error into it
						- return object with value
						- IOT
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### async generator
						```js
						let runGenerator = function(generatorFunction) {
							// recursive next()
							let next = function (arg) {
								let result = it.next(arg);
								// are we done?
								if (result.done) return;

								if (typeof result.value == 'function') {
									result.value(next);
								}
								else {
									// if the response isn't a function, pass it to next()
									next(result.value);
								}
							}
							// create the iterator
							let it = generatorFunction();
							return next();
						}

						// initiliase and pass in a generator function
						runGenerator(function* () {
							let val = yield fetch(url);
							let val2 = yield fetch(url2);
						});
						```
						Note:
						  - call runGenerator, pass GenFunc
						  - runGenerator defines a recursive called function next
						  - creates a genObj
							- next called itself until genObj is done
						  - resolve Promises gets from genObj, pass result to genObj
							- simplified example
							- libs like coroutine
							- why we shouldn't use async await?
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### ember-concurrency
						```js
						export default Ember.Component.extend({
							result: null,
							actions: {
								async getProducts() {
									let products = await this.get('store').get('products');
									this.set('result', products);
								}
							},
						});
						```
						Note:
						- Component has a lifecycle
						- it maybe destroyed
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### ember-concurrency

						```js
						export default Ember.Component.extend({
							result: null,
							fetching: false,
							actions: {
								async getProducts() {
									if (this.get('fetching')) { return; }
									this.set('fetching', true);
									try {
										let products = await this.get('store').get('products');
										if (this.get('isDestroyed')) { return; }
										this.set('result', products);
									} finally (err) {
										if (this.get('isDestroyed')) { return; }
										this.set('fetching', false);
									}
								}
							},
						});

						```
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### ember-concurrency
						```js
						export default Ember.Component.extend({
							result: null,
							getProducts: task(function* () {
								let products = yield this.get('store').get('products');
								this.set('result', product);
							}).drop()
						});
						```
						Note:
							- No isDetroyed guard anymore, cause it cancel
							- No fetching guard anymore, cause of modifier
							- Thanks to IOC of genObs
					</script>
				</section>
				<section>
					<h1>Thank you</h1>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
        transition: 'default',
        progress: false,
        slideNumber: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
