<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Async Javascript</title>

		<script src="https://use.typekit.net/dkq5epu.js"></script>
		<script>try{Typekit.load({ async: true });}catch(e){}</script>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/kaliber5.css">
		<link rel="stylesheet" href="css/spinner.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Async Javascript</h1>
					<h2>Callbacks, Promises, Async/Await</h2>
					<div class="floatingBarsG">
						<div class="blockG rotateG_01"></div>
						<div class="blockG rotateG_02"></div>
						<div class="blockG rotateG_03"></div>
						<div class="blockG rotateG_04"></div>
						<div class="blockG rotateG_05"></div>
						<div class="blockG rotateG_06"></div>
						<div class="blockG rotateG_07"></div>
						<div class="blockG rotateG_08"></div>
					</div>
				</section>
				<section>
					<div class="id-card">
						<dl>
							<dt>Name</dt>
							<dd>Andreas Schacht</dd>
							<dt>Company</dt>
							<dd><a href="http://www.kaliber5.de">kaliber5</a></dd>
							<dt>Job title</dt>
							<dd>Web Developer</dd>
							<dt>Email</dt>
							<dd><a href="mailto:schacht@kaliber5.de">schacht@kaliber5.de</a></dd>
						</dl>
					</div>
					<aside class="notes">
						Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the
						speaker notes window (hit 's' on your keyboard).
					</aside>
				</section>
				<section data-markdown>
					<script type="text/template">
						## TOC
						what will I talk about
						- sync example
						- callback example
						- promise example
						- async/await example
						- async with generators
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Sync

						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						let result = doSomething();
						console.log(result);
						```
						Note:
						- very common use case
						- process depends on result of previous one
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Sync

						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						try {
							let result = doSomething();
							console.log(result);
						} catch(err) {
							console.error(err);
						}
						```
						- handle errors
					</script>
				</section>
				<section>
					<div class="floatingBarsG">
						<div class="blockG rotateG_01"></div>
						<div class="blockG rotateG_02"></div>
						<div class="blockG rotateG_03"></div>
						<div class="blockG rotateG_04"></div>
						<div class="blockG rotateG_05"></div>
						<div class="blockG rotateG_06"></div>
						<div class="blockG rotateG_07"></div>
						<div class="blockG rotateG_08"></div>
					</div>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Callbacks
						```js
						function bar(value) {
							console.log(value);
						}

						function foo(cb) {
							setTimeout(function() {
								cb(2);
							}, 1000);
						}

						foo(bar);
						console.log(1);

						//-> 1
						//-> 2
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Callbacks

						```js
						const fs = require('fs');

						fs.readFile('./README.md', (err, data) => {
							// do some work here
						});
						```
						- "error-first"- / "errback"-convention
						- err is null on success

						Note:
						- respect error handling
						- avoid forget/skip err
						- signature is just a convention
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Callbacks

						```js
						const fs = require('fs');

						fs.readFile('./README.md', (err, data) => {
							if (err) {
								// handle error
							} else {
								// process data
							}
						});

						```
						Note:
						- construct will look like this
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Callbacks

						```js
						const fs = require('fs');

						try {
							fs.readFile('./README.md', (err, data) => {
								if (err) {
									throw err;
								}
								console.log('done');
							});
						} catch(err) {
							console.error(err);
						}
						```
						- try / catch won't work
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Callbacks

						```js
						function doSomething(cb) {
							foo((err, data) => {
								bar(data, (err, data) => {
									baz(data, cb);
								});
							});
						}

						doSomething((err, data) => {
							console.log(data);
						});
						```
						Note:
						- harder to read
						- indentation
						- nested level 3
						- not finished yet
							- handle errors
					</script>
				</section>
				<section data-markdown class="md-small md-code-large">
					<script type="text/template">
						#### Callbacks

						```js
						function doSomething(cb) {
							foo((err, data) => {
								if (err) {
									cb(err);
								} else {
									bar(data, (err, data) => {
										if (err) {
											cb(err);
										} else {
											baz(data, cb);
										}
									});
								}
							});
						}

						doSomething((err, data) => {
							if (err) {
								console.error(err);
							} else {
								console.log(data);
							}
						});
						```
						- error handling
						Note:
						- very hard to read
						- indentation, high nested level
						- callback hell
						- shape of pyramid
						- known as pyramid of doom
						- exit as soon as possible
						- skip else block
						- skip further execution
					</script>
				</section>
				<section data-markdown class="md-small md-code-large">
					<script type="text/template">
						#### Callbacks

						```js
						function doSomething(cb) {
							foo((err, data) => {
								if (err) {
									return cb(err);
								}
								bar(data, (err, data) => {
									if (err) {
										return cb(err);
									}
									baz(data, cb);
								});
							});
						}

						doSomething((err, data) => {
							if (err) {
								return console.error(err);
							}
							console.log(data);
						});
						```
						- exit as soon as possible
						Note:
						- skip else block
						- skip further execution
						- compare to sync example
					</script>
				</section>
				<section data-markdown class="md-small md-code-large">
					<script type="text/template">
						#### Callbacks vs Sync
						```js
						function doSomething(cb) {
							foo((err, data) => {
								if (err) {
									return cb(err);
								}
								bar(data, (err, data) => {
									if (err) {
										return cb(err);
									}
									baz(data, cb);
								});
							});
						}

						doSomething((err, data) => {
							if (err) {
								return console.error(err);
							}
							console.log(data);
						});
						```
						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						try {
							let result = doSomething();
							console.log(result);
						} catch(err) {
							console.error(err);
						}
						```
						Note:
						- high indentation level
						- lost readability
							- not really intuitive like first
						- many blocks
						- far away from first example
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						- objects represents an eventual result/failure

						```js
						new Promise(function(resolve, reject) { ... } );
						```
						<div class="fragment fade-in">
						- states
						<pre>pending := !fulfilled && !rejected</pre>
						<pre>fulfilled</pre>
						<pre>rejected</pre>
						</div>
						Note:
						- became 1st class citizen of modern frameworks
						- avoid basics
						- focus on traps/edge cases
						- pass executor function
						- pending is initial state
						- settled := !pending <=> fulfilled || rejected
						- resolved := fulfilled || rejected || follow thenable/promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
							new Promise((resolve, reject) => {
								// executes immediatly
								// do some work
								// pending state
								if (foo) {
									resolve(foo);
									// fulfilled state
								} else {
									reject(reason);
									// rejected state
								}
							});
						```
						Note:
							- work should be async
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						Promise.reject('reason');
						// state rejected

						Promise.resolve('value');
						// state fulfilled

						Promise.resolve(Promise.reject('reason'));
						// return passed Promise, state rejected
						```
						Note:
						- if pass a promise, resolve returns that promise
					</script>
					</section>
					<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						Promise.all([
							Promise.resolve('val1'),
							Promise.resolve('val2')
						]); // resolves async, state pending, will fulfill

						Promise.all([]); // resolves sync, state fulfilled

						Promise.all([
							'val1',
							'val2'
						]); // resolves async (sync on Chrome 58), state pending (fulfilled), will fulfill

						Promise.all([
							Promise.resolve('value'),
							Promise.reject('reason')
						]); // resolves sync, state rejected
						```
						Note:
						- Promise.all(iterable); Array/String
						- all is fulfilled, if all promises are fulfilled
						- all is rejected, if at least one promise is rejected
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						Promise.race([
							Promise.resolve('val1'),
							Promise.reject('val2')
						]); // state pending, will fulfill with value: 'val1'

						Promise.race([
							Promise.reject('val2'),
							Promise.resolve('val1')
						]); // state pending, will reject with reason: 'val2'

						Promise.race([]); // will pending forever
						```
						Note:
						- Promise.race(iterable); Array/String
						- race follows the first settled
						- race pending foreverfollows the first settled
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises

						```js
						Promise.prototype.then(onFulfilled[, onRejected]);

						Promise.resolve('value').then((data) => {
							console.log(data);
						});

						Promise.reject('reason').then((data) => {},
						(reason) => {
								console.error(reason);
						});

						Promise.prototype.catch(onRejected);

						Promise.reject('reason').catch((reason) => {
							console.error(reason);
						});
						```
						Note:
						- provides then/catch
						- catch is the same as then(null, onRejected)
						- returns a promise, so it's chainable
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.reject(Error('test'));

						 // -> Uncaught (in promise) Error: test
						```
						Note:
						- keep in mind, then/catch returns a promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.reject(Error('test'));
						promise.catch((error) => {
							// handle error
						});

						 // -> No output
						```
						Note:
						- keep in mind, then/catch returns a promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.reject(Error('test'));
						promise.catch((error) => {
							// handle error
						});

						promise.then((value) => {
							// will never executed
						});
						 // -> Uncaught (in promise) Error: test
						```
						Note:
						- keep in mind, then/catch returns a promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.reject(Error('test'));
						promise.catch((error) => {
							// handle error
						});

						promise.then((value) => {
							// will never executed
						}, (err) => {});

						promise.then((value) => {
							// will never executed
						}).catch((err) => {});
						// -> No output
						```
						Note:
						- keep in mind, then/catch returns a promise
						- chain multiple methods on same promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.resolve({ name: 'Andreas'});
						promise.then((value) => {
							console.log('1: '+value.name);
							value.name = 'Andi';
							return value;
						}).then((value) => {
							console.log('2: '+value.name);
						});
						// -> 1: Andreas
						// -> 2: Andi
						```
						Note:
						- chain multiple methods on same promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.resolve({ name: 'Andreas'});
						promise.then((value) => {
							console.log('1: '+value.name);
							value.name = 'Andi';
							return value;
						}).then((value) => {
							console.log('2: '+value.name);
						});
						// ....
						promise.then((value) => {
							console.log('1.5: '+value.name);
							value.name = 'Andy';
						});
						// -> 1: Andreas
						// -> 1.5: Andi
						// -> 2: Andy
						```
						Note:
						- idea
						- chain multiple methods on same promise
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						#### chainable

						```js
						Promise.resolve().then((data) => {
							return Promise.resolve('data');
						}).then((data) => {
							console.log(data); // -> 'data'
							return 42;
						}).then(undefined, (error) => {
							// this will never been reached
						}).then((data) => {
							console.log(data); // -> 42
							throw Error('message');
						}).then((data) => {
							// this will never been reached
						}).catch((error) => {
							// handle error;
						});

						```
						Note:
						- chainable through then function
						- value will pass through the chain to the next handler, if undefined (or not a function)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						...swallow errors?

						```js
						let promise = Promise.resolve().then((data) => {
							throw Error('message');
						});
						// ...some more code

						```
						What happens now?
						Note:
						- theoretical to me
						- try to reproduce, never managed
						- not popped up, immediatly
						- promise is in rejected state
						- there are 2 options
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						You can chain the catch later

						```js
						let promise = Promise.resolve().then((data) => {
							throw new Error('message');
						});
						//
						// ...in another part of code
						//
						promise.catch((error) => {
							console.error(error);
						});
						```
						Note:
							- add catch to the chain
							- As long as the promise live
							- promise is accessable
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						```js
						let promise = Promise.resolve().then((data) => {
							throw new Error('message');
						});
						//
						// ..if promise is settled and out of scope...
						// ..the error will popup on garbage-collection
						```
						Note:
							- hard to say when
							- don't forget to catch
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						#### wrap callback style

						```js
						const fs = require('fs');

						fs.readFile('./README.md', (err, data) => {
							if (err) {
								// handle error
							} else {
								// process data
							}
						});

						```
						Note:
						- tired of callbacks
						- from previous explaination
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Promises
						#### wrap callback style

						```js
						const fs = require('fs');

						let promise = new Promise((resolve, reject) => {
							fs.readFile('./README.md', (err, data) => {
								if (err) {
									return reject(err);
								}
								resolve(data);
							});
						});

						promise.then((data) => {
							// will be called, if promise resolves
						}).catch((err) => {
							// will be called, when promise rejects
						});

						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						function doSomething() {
							return Promise.resolve(foo())
								.then((data) => {
									return bar(data);
								})
								.then((data) => {
									return baz(data);
								});
						}

						doSomething().then((data) => {
							console.log(data);
						}).catch((error) => {
							console.error(error);
						});
						```
						Note:
						- short syntax
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### Promises
						```js
						function doSomething() {
							return Promise.resolve(foo())
								.then(bar)
								.then(baz);
						}

						doSomething().then((data) => {
							console.log(data);
						}).catch((error) =>
							console.error(error);
						});
						```
						Note:
						- short syntax
					</script>
				</section>
				<section data-markdown class="md-small md-code-large">
					<script type="text/template">
						#### Promises vs Sync
						```js
						function doSomething() {
							return Promise.resolve(foo())
								.then(bar)
								.then(baz);
						}

						doSomething().then((data) => {
							console.log(data);
						}).catch((error) =>
							console.error(error);
						});
						```
						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						try {
							let result = doSomething();
							console.log(result);
						} catch(err) {
							console.error(err);
						}
						```
						Note:
						- good, but not satisfied
						- have another bullet
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### async / await
						- RC ES7
						- `async function`
							- will return a Promise
						- `await` keyword
							- suspending execution in context
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### async / await
						```js
						async function() {
							let value = await Promise.resolve('value');
							await Promise.reject(Error('reason'));
							...
						}
						```
						Note:
						- what happens
							- onFulfill: await returns the resolved value
							- onRejection: await throws an error
								- promise returned by async rejects
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### async / await
						```js
						async function(file) {
							try {
								let value = await Promise.resolve('value');
								await Promise.reject(Error('reason'));
								// do something
								return 'result'; // never reached
							} catch(error) {
								// handle error
								// return fallbackValue;
								// 	or
								// throw error;
							}
						...
						}
						```
						Note:
						- try / catch like in sync context
						- Now see our Example
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						#### async/await vs Sync
						```js
						async function doSomething() {
							let data = await foo();
							data = await bar(data);
							return await baz(data);
						}

						doSomething().then((data) => {
							console.log(data);
						}).catch((error) =>
							console.error(error);
						});
						```
						```js
						function doSomething() {
							let data = foo();
							data = bar(data);
							return baz(data);
						}

						try {
							let result = doSomething();
							console.log(result);
						} catch(err) {
							console.error(err);
						}
						```
						Note:
						- almost the same
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### async / await
						parallel execution
						```js

						async function () {
							let promA = new Promise(...);
							let promB = new Promise(...);

							return await promA + await promB;
						}

						async function () {
							let [resultA, resultB] = await Promise.all([
								new Promise(...),
								new Promise(...)
							]);

							return resultA + resultBB;
						}
						```
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator
						- pass argument to generator function
						- generator object saves it's state while suspending

						```js

						function* generatorFunction(startval) {
							let current = startval;
							while(current > 0) {
								yield current;
								current--;
							}
						}

						let generatorObject = generatorFunction(3);

						console.log(generatorObject.next());

						for (let number of generatorObject ) {
							console.log(number);
						}

						console.log(generatorObject.next());
						// { done: false, value: 3}, 2,  1, { done: true }
						```
						Note:
							- iterable: g[Symbol.iterator] === function
							- iterable: g[Symbol.iterator]: () => ({ next() { return { done: true, value: 1 }})
							- iterable: @@iterator
							- iterator: g.next === function
							- suspend / resume
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator
						- pass value to yield

						```js
						function* generatorFunction(startval) {
							let current = startval;
							while(current > 0) {
								let restart = yield current;
								if (restart) {
									current = startval;
								else {
									current--;
								}
							}
						}

						let generatorObject = generatorFunction(3);

						//will throw an error
						//console.log(generatorObject.next(true));

						console.log(generatorObject.next().value);
						console.log(generatorObject.next(true).value);
						console.log(generatorObject.next().value);
						// 3, 2, 3
						```
						Note:
						- iterable: g[Symbol.iterator] === function
						- iterable: g[Symbol.iterator]: () => ({ next() { return { done: true, value: 1 }})
						- iterable: @@iterator
						- iterator: g.next === function
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator
						- IoC

						```js
						function* generatorFunction() {
							yield false;
							yield true;
							yield false;
						}

						let generatorObject = generatorFunction();
						let startval = 3;
						let currentval = startval;
						while(true) {
							let reset = generatorObject.next();
							console.log(currentval);
							if (reset.value) {
								currentval = startval;
							} else {
								currentval--;
							}
							if (reset.done || currentval < 1) {
								break;
							}
						}
						// will output 3, 2, 3
						```
						Note:
						- iterable: g[Symbol.iterator] === function
						- iterable: g[Symbol.iterator]: () => ({ next() { return { done: true, value: 1 }})
						- iterable: @@iterator
						- iterator: g.next === function
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator
						- IoC

						```js
						function* generatorFunction() {
							yield false;
							yield true;
							yield false;
						}

						function printCount(genFunc, startval) {
							let generatorObject = genFunc();
							let currentval = startval;
							while(true) {
								let reset = generatorObject.next();
								console.log(currentval);
								if (reset.value) {
									currentval = startval;
								} else {
									currentval--;
								}
								if (reset.done || currentval < 1) {
									break;
								}
							}
						}

						printCount(generatorFunction, 3);
						//  3, 2 3

						```
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator
						- IoC

						```js
						function* logMessages() {
							yield 'Message 1';
							yield 'Message 2';
							yield 'Message 3';
						}

						function remoteLogger(genFunc) {
							let generatorObject = genFunc();
							getNext();

							function getNext() {
								let message = generatorObject.next();
								if (message.done) {
									return;
								}
								remoteLog(message.value, getNext);
							},

							function remoteLog(value, next) {
								ajax.post('https://my-remote-log.com', { value })
								.then(() => {
									next();
								});
							}
						}
						remoteLogger(logMessages);
						```
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator

						```js
						function remoteLogger(genFunc) {
							let generatorObject = genFunc();
							getNext();

							function getNext() {
								let message = generatorObject.next();
								if (message.done) {
									return;
								}
								remoteLog(message.value, getNext);
							},
							function remoteLog(value, next) {
								ajax.post('https://my-remote-log.com', { value })
								.then(() => {
									next();
								});
							}
						}
						remoteLogger(function* logMessages() {
							yield 'Message 1';
							yield 'Message 2';
							yield 'Message 3';
						});
						```
					</script>
				</section>
				<section data-markdown class="md-code-large">
					<script type="text/template">
						#### generator

						```js
						function remoteLogger(genFunc) {
							let generatorObject = genFunc();
							getNext();
							function getNext() {
								let message = generatorObject.next();
								if (message.done) {
									return;
								}
								remoteLog(message.value, getNext);
							},
							function remoteLog(value, next) {
								ajax.post('https://my-remote-log.com', { value })
								.then(() => {
									next();
								}, (err) => {
									generatorObject.throw(error);
								});
							}
						}
						remoteLogger(function* logMessages() {
							try {
								yield 'Message 1';
								yield 'Message 2';
								yield 'Message 3';
							} catch(err) {
								console.error(err);
							}
						});
						```
					</script>
				</section>
				<section>
					<h1>Thank you</h1>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
        transition: 'default',
        progress: false,
        slideNumber: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
